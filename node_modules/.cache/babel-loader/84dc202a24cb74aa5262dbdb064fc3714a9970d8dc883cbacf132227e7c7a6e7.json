{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute, Mesh, MeshBasicMaterial, Vector3, DataTexture, RGBAFormat, NearestFilter, ClampToEdgeWrapping, RawShaderMaterial, Color, Vector2, AdditiveBlending, Box2, Vector4 } from \"three\";\nconst geometry = new BufferGeometry();\nconst float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\nconst interleavedBuffer = new InterleavedBuffer(float32Array, 5);\ngeometry.setIndex([0, 1, 2, 0, 2, 3]);\ngeometry.setAttribute(\"position\", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\ngeometry.setAttribute(\"uv\", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\nconst _Lensflare = class extends Mesh {\n  constructor() {\n    super(_Lensflare.Geometry, new MeshBasicMaterial({\n      opacity: 0,\n      transparent: true\n    }));\n    this.isLensflare = true;\n    this.type = \"Lensflare\";\n    this.frustumCulled = false;\n    this.renderOrder = Infinity;\n    const positionScreen = new Vector3();\n    const positionView = new Vector3();\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    tempMap.minFilter = NearestFilter;\n    tempMap.magFilter = NearestFilter;\n    tempMap.wrapS = ClampToEdgeWrapping;\n    tempMap.wrapT = ClampToEdgeWrapping;\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    occlusionMap.minFilter = NearestFilter;\n    occlusionMap.magFilter = NearestFilter;\n    occlusionMap.wrapS = ClampToEdgeWrapping;\n    occlusionMap.wrapT = ClampToEdgeWrapping;\n    const geometry2 = _Lensflare.Geometry;\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader: ( /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`),\n      fragmentShader: ( /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`),\n      depthTest: true,\n      depthWrite: false,\n      transparent: false\n    });\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: tempMap\n        },\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader: ( /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`),\n      fragmentShader: ( /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`),\n      depthTest: false,\n      depthWrite: false,\n      transparent: false\n    });\n    const mesh1 = new Mesh(geometry2, material1a);\n    const elements = [];\n    const shader = LensflareElement.Shader;\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: null\n        },\n        occlusionMap: {\n          value: occlusionMap\n        },\n        color: {\n          value: new Color(16777215)\n        },\n        scale: {\n          value: new Vector2()\n        },\n        screenPosition: {\n          value: new Vector3()\n        }\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false\n    });\n    const mesh2 = new Mesh(geometry2, material2);\n    this.addElement = function (element) {\n      elements.push(element);\n    };\n    const scale = new Vector2();\n    const screenPositionPixels = new Vector2();\n    const validArea = new Box2();\n    const viewport = new Vector4();\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport);\n      const invAspect = viewport.w / viewport.z;\n      const halfViewportWidth = viewport.z / 2;\n      const halfViewportHeight = viewport.w / 2;\n      let size = 16 / viewport.w;\n      scale.set(size * invAspect, size);\n      validArea.min.set(viewport.x, viewport.y);\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));\n      positionView.setFromMatrixPosition(this.matrixWorld);\n      positionView.applyMatrix4(camera.matrixWorldInverse);\n      if (positionView.z > 0) return;\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;\n      if (validArea.containsPoint(screenPositionPixels)) {\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);\n        let uniforms = material1a.uniforms;\n        uniforms[\"scale\"].value = scale;\n        uniforms[\"screenPosition\"].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry2, material1a, mesh1, null);\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);\n        uniforms = material1b.uniforms;\n        uniforms[\"scale\"].value = scale;\n        uniforms[\"screenPosition\"].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry2, material1b, mesh1, null);\n        const vecX = -positionScreen.x * 2;\n        const vecY = -positionScreen.y * 2;\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i];\n          const uniforms2 = material2.uniforms;\n          uniforms2[\"color\"].value.copy(element.color);\n          uniforms2[\"map\"].value = element.texture;\n          uniforms2[\"screenPosition\"].value.x = positionScreen.x + vecX * element.distance;\n          uniforms2[\"screenPosition\"].value.y = positionScreen.y + vecY * element.distance;\n          size = element.size / viewport.w;\n          const invAspect2 = viewport.w / viewport.z;\n          uniforms2[\"scale\"].value.set(size * invAspect2, size);\n          material2.uniformsNeedUpdate = true;\n          renderer.renderBufferDirect(camera, null, geometry2, material2, mesh2, null);\n        }\n      }\n    };\n    this.dispose = function () {\n      material1a.dispose();\n      material1b.dispose();\n      material2.dispose();\n      tempMap.dispose();\n      occlusionMap.dispose();\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose();\n      }\n    };\n  }\n};\nlet Lensflare = _Lensflare;\n__publicField(Lensflare, \"Geometry\", geometry);\nclass LensflareElement {\n  constructor(texture, size = 1, distance = 0, color = new Color(16777215)) {\n    this.texture = texture;\n    this.size = size;\n    this.distance = distance;\n    this.color = color;\n  }\n}\n__publicField(LensflareElement, \"Shader\", {\n  uniforms: {\n    map: {\n      value: null\n    },\n    occlusionMap: {\n      value: null\n    },\n    color: {\n      value: null\n    },\n    scale: {\n      value: null\n    },\n    screenPosition: {\n      value: null\n    }\n  },\n  vertexShader: ( /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`),\n  fragmentShader: ( /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`)\n});\nexport { Lensflare, LensflareElement };","map":{"version":3,"names":["geometry","BufferGeometry","float32Array","Float32Array","interleavedBuffer","InterleavedBuffer","setIndex","setAttribute","InterleavedBufferAttribute","_Lensflare","Mesh","constructor","Geometry","MeshBasicMaterial","opacity","transparent","isLensflare","type","frustumCulled","renderOrder","Infinity","positionScreen","Vector3","positionView","tempMap","DataTexture","Uint8Array","RGBAFormat","minFilter","NearestFilter","magFilter","wrapS","ClampToEdgeWrapping","wrapT","occlusionMap","geometry2","material1a","RawShaderMaterial","uniforms","scale","value","screenPosition","vertexShader","fragmentShader","depthTest","depthWrite","material1b","map","mesh1","elements","shader","LensflareElement","Shader","material2","color","Color","Vector2","blending","AdditiveBlending","mesh2","addElement","element","push","screenPositionPixels","validArea","Box2","viewport","Vector4","onBeforeRender","renderer","scene","camera","getCurrentViewport","invAspect","w","z","halfViewportWidth","halfViewportHeight","size","set","min","x","y","max","setFromMatrixPosition","matrixWorld","applyMatrix4","matrixWorldInverse","copy","projectionMatrix","containsPoint","copyFramebufferToTexture","renderBufferDirect","vecX","vecY","i","l","length","uniforms2","texture","distance","invAspect2","uniformsNeedUpdate","dispose","Lensflare","__publicField"],"sources":["D:\\valentines_website\\node_modules\\src\\objects\\Lensflare.js"],"sourcesContent":["import {\n  AdditiveBlending,\n  Box2,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DataTexture,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Mesh,\n  MeshBasicMaterial,\n  NearestFilter,\n  RGBAFormat,\n  RawShaderMaterial,\n  Vector2,\n  Vector3,\n  Vector4,\n} from 'three'\n\nconst geometry = new BufferGeometry()\n\nconst float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1])\n\nconst interleavedBuffer = new InterleavedBuffer(float32Array, 5)\n\ngeometry.setIndex([0, 1, 2, 0, 2, 3])\ngeometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false))\ngeometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false))\n\nclass Lensflare extends Mesh {\n  static Geometry = geometry\n\n  constructor() {\n    super(Lensflare.Geometry, new MeshBasicMaterial({ opacity: 0, transparent: true }))\n\n    this.isLensflare = true\n\n    this.type = 'Lensflare'\n    this.frustumCulled = false\n    this.renderOrder = Infinity\n\n    //\n\n    const positionScreen = new Vector3()\n    const positionView = new Vector3()\n\n    // textures\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat)\n    tempMap.minFilter = NearestFilter\n    tempMap.magFilter = NearestFilter\n    tempMap.wrapS = ClampToEdgeWrapping\n    tempMap.wrapT = ClampToEdgeWrapping\n\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat)\n    occlusionMap.minFilter = NearestFilter\n    occlusionMap.magFilter = NearestFilter\n    occlusionMap.wrapS = ClampToEdgeWrapping\n    occlusionMap.wrapT = ClampToEdgeWrapping\n\n    // material\n\n    const geometry = Lensflare.Geometry\n\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: { value: null },\n        screenPosition: { value: null },\n      },\n      vertexShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n      fragmentShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n      depthTest: true,\n      depthWrite: false,\n      transparent: false,\n    })\n\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: { value: tempMap },\n        scale: { value: null },\n        screenPosition: { value: null },\n      },\n      vertexShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n      fragmentShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n      depthTest: false,\n      depthWrite: false,\n      transparent: false,\n    })\n\n    // the following object is used for occlusionMap generation\n\n    const mesh1 = new Mesh(geometry, material1a)\n\n    //\n\n    const elements = []\n\n    const shader = LensflareElement.Shader\n\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: { value: null },\n        occlusionMap: { value: occlusionMap },\n        color: { value: new Color(0xffffff) },\n        scale: { value: new Vector2() },\n        screenPosition: { value: new Vector3() },\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false,\n    })\n\n    const mesh2 = new Mesh(geometry, material2)\n\n    this.addElement = function (element) {\n      elements.push(element)\n    }\n\n    //\n\n    const scale = new Vector2()\n    const screenPositionPixels = new Vector2()\n    const validArea = new Box2()\n    const viewport = new Vector4()\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport)\n\n      const invAspect = viewport.w / viewport.z\n      const halfViewportWidth = viewport.z / 2.0\n      const halfViewportHeight = viewport.w / 2.0\n\n      let size = 16 / viewport.w\n      scale.set(size * invAspect, size)\n\n      validArea.min.set(viewport.x, viewport.y)\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16))\n\n      // calculate position in screen space\n\n      positionView.setFromMatrixPosition(this.matrixWorld)\n      positionView.applyMatrix4(camera.matrixWorldInverse)\n\n      if (positionView.z > 0) return // lensflare is behind the camera\n\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix)\n\n      // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8\n\n      // screen cull\n\n      if (validArea.containsPoint(screenPositionPixels)) {\n        // save current RGB to temp texture\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap)\n\n        // render pink quad\n\n        let uniforms = material1a.uniforms\n        uniforms['scale'].value = scale\n        uniforms['screenPosition'].value = positionScreen\n\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null)\n\n        // copy result to occlusionMap\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap)\n\n        // restore graphics\n\n        uniforms = material1b.uniforms\n        uniforms['scale'].value = scale\n        uniforms['screenPosition'].value = positionScreen\n\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null)\n\n        // render elements\n\n        const vecX = -positionScreen.x * 2\n        const vecY = -positionScreen.y * 2\n\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i]\n\n          const uniforms = material2.uniforms\n\n          uniforms['color'].value.copy(element.color)\n          uniforms['map'].value = element.texture\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance\n\n          size = element.size / viewport.w\n          const invAspect = viewport.w / viewport.z\n\n          uniforms['scale'].value.set(size * invAspect, size)\n\n          material2.uniformsNeedUpdate = true\n\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null)\n        }\n      }\n    }\n\n    this.dispose = function () {\n      material1a.dispose()\n      material1b.dispose()\n      material2.dispose()\n\n      tempMap.dispose()\n      occlusionMap.dispose()\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose()\n      }\n    }\n  }\n}\n\n//\n\nclass LensflareElement {\n  static Shader = {\n    uniforms: {\n      map: { value: null },\n      occlusionMap: { value: null },\n      color: { value: null },\n      scale: { value: null },\n      screenPosition: { value: null },\n    },\n\n    vertexShader: /* glsl */ `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`,\n  }\n\n  constructor(texture, size = 1, distance = 0, color = new Color(0xffffff)) {\n    this.texture = texture\n    this.size = size\n    this.distance = distance\n    this.color = color\n  }\n}\n\nexport { Lensflare, LensflareElement }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}