{"ast":null,"code":"import { Vector2 } from \"three\";\nconst FreiChenShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    aspect: {\n      value: new Vector2(512, 512)\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform vec2 aspect;\", \"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\", \"mat3 G[9];\",\n  // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n  \"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\", \"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\", \"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\", \"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\", \"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\", \"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\", \"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\", \"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\", \"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\", \"void main(void)\", \"{\", \"\tG[0] = g0,\", \"\tG[1] = g1,\", \"\tG[2] = g2,\", \"\tG[3] = g3,\", \"\tG[4] = g4,\", \"\tG[5] = g5,\", \"\tG[6] = g6,\", \"\tG[7] = g7,\", \"\tG[8] = g8;\", \"\tmat3 I;\", \"\tfloat cnv[9];\", \"\tvec3 sample;\", /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n  \"\tfor (float i=0.0; i<3.0; i++) {\", \"\t\tfor (float j=0.0; j<3.0; j++) {\", \"\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\", \"\t\t\tI[int(i)][int(j)] = length(sample);\", \"\t\t}\", \"\t}\", /* calculate the convolution values for all the masks */\n  \"\tfor (int i=0; i<9; i++) {\", \"\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\", \"\t\tcnv[i] = dp3 * dp3;\", \"\t}\", \"\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\", \"\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\", \"\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\", \"}\"].join(\"\\n\")\n};\nexport { FreiChenShader };","map":{"version":3,"names":["FreiChenShader","uniforms","tDiffuse","value","aspect","Vector2","vertexShader","join","fragmentShader"],"sources":["D:\\valentines_website\\node_modules\\src\\shaders\\FreiChenShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Edge Detection Shader using Frei-Chen filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nexport const FreiChenShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    aspect: { value: new Vector2(512, 512) },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'varying vec2 vUv;',\n\n    'uniform vec2 aspect;',\n\n    'vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);',\n\n    'mat3 G[9];',\n\n    // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n    'const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );',\n    'const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );',\n    'const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );',\n    'const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );',\n    'const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );',\n    'const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );',\n    'const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );',\n    'const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );',\n    'const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );',\n\n    'void main(void)',\n    '{',\n\n    '\tG[0] = g0,',\n    '\tG[1] = g1,',\n    '\tG[2] = g2,',\n    '\tG[3] = g3,',\n    '\tG[4] = g4,',\n    '\tG[5] = g5,',\n    '\tG[6] = g6,',\n    '\tG[7] = g7,',\n    '\tG[8] = g8;',\n\n    '\tmat3 I;',\n    '\tfloat cnv[9];',\n    '\tvec3 sample;',\n\n    /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n    '\tfor (float i=0.0; i<3.0; i++) {',\n    '\t\tfor (float j=0.0; j<3.0; j++) {',\n    '\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;',\n    '\t\t\tI[int(i)][int(j)] = length(sample);',\n    '\t\t}',\n    '\t}',\n\n    /* calculate the convolution values for all the masks */\n    '\tfor (int i=0; i<9; i++) {',\n    '\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);',\n    '\t\tcnv[i] = dp3 * dp3;',\n    '\t}',\n\n    '\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);',\n    '\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);',\n\n    '\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);',\n    '}',\n  ].join('\\n'),\n}\n"],"mappings":";AASO,MAAMA,cAAA,GAAiB;EAC5BC,QAAA,EAAU;IACRC,QAAA,EAAU;MAAEC,KAAA,EAAO;IAAK;IACxBC,MAAA,EAAQ;MAAED,KAAA,EAAO,IAAIE,OAAA,CAAQ,KAAK,GAAG;IAAE;EACzC;EAEAC,YAAA,EAAc,CACZ,qBAEA,iBAEA,cACA,8EAEA,KACAC,IAAA,CAAK,IAAI;EAEXC,cAAA,EAAgB,CACd,+BACA,qBAEA,wBAEA,sDAEA;EAAA;EAIA,iIACA,iIACA,iIACA,iIACA,gEACA,gEACA,mNACA,mNACA,+MAEA,mBACA,KAEA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eAEA,YACA,kBACA;EAGA,oCACA,qCACA,0EACA,0CACA,OACA;EAGA,8BACA,+EACA,yBACA,MAEA,qDACA,oEAEA,+CACA,KACAD,IAAA,CAAK,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}