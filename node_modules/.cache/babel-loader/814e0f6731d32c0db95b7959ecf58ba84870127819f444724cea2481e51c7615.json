{"ast":null,"code":"import { Vector2, Matrix4 } from \"three\";\nconst SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 5e-3\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tNormal;\", \"uniform sampler2D tDepth;\", \"uniform sampler2D tNoise;\", \"uniform vec3 kernel[ KERNEL_SIZE ];\", \"uniform vec2 resolution;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform mat4 cameraProjectionMatrix;\", \"uniform mat4 cameraInverseProjectionMatrix;\", \"uniform float kernelRadius;\", \"uniform float minDistance;\",\n  // avoid artifacts caused by neighbour fragments with minimal depth difference\n  \"uniform float maxDistance;\",\n  // avoid the influence of fragments which are too far away\n  \"varying vec2 vUv;\", \"#include <packing>\", \"float getDepth( const in vec2 screenPosition ) {\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"}\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\", \"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\", \"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\", \"\tclipPosition *= clipW; // unprojection.\", \"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\", \"}\", \"vec3 getViewNormal( const in vec2 screenPosition ) {\", \"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tfloat viewZ = getViewZ( depth );\", \"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\", \"\tvec3 viewNormal = getViewNormal( vUv );\", \" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\", \"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n  // compute matrix used to reorient a kernel vector\n  \"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\", \"\tvec3 bitangent = cross( viewNormal, tangent );\", \"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\", \" float occlusion = 0.0;\", \" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\", \"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\",\n  // reorient sample vector in view space\n  \"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\",\n  // calculate sample point\n  \"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\",\n  // project point and calculate NDC\n  \"\t\tsamplePointNDC /= samplePointNDC.w;\", \"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\",\n  // compute uv coordinates\n  \"\t\tfloat realDepth = getLinearDepth( samplePointUv );\",\n  // get linear depth from depth texture\n  \"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\",\n  // compute linear depth of the sample view Z value\n  \"\t\tfloat delta = sampleDepth - realDepth;\", \"\t\tif ( delta > minDistance && delta < maxDistance ) {\",\n  // if fragment is before sample point, increase occlusion\n  \"\t\t\tocclusion += 1.0;\", \"\t\t}\", \"\t}\", \"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\", \"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nconst SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"varying vec2 vUv;\", \"#include <packing>\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getLinearDepth( vUv );\", \"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 texelSize = ( 1.0 / resolution );\", \"\tfloat result = 0.0;\", \"\tfor ( int i = - 2; i <= 2; i ++ ) {\", \"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\", \"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\", \"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };","map":{"version":3,"names":["SSAOShader","defines","PERSPECTIVE_CAMERA","KERNEL_SIZE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","kernel","cameraNear","cameraFar","resolution","Vector2","cameraProjectionMatrix","Matrix4","cameraInverseProjectionMatrix","kernelRadius","minDistance","maxDistance","vertexShader","join","fragmentShader","SSAODepthShader","SSAOBlurShader"],"sources":["D:\\valentines_website\\node_modules\\src\\shaders\\SSAOShader.ts"],"sourcesContent":["import { Matrix4, Vector2 } from 'three'\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nexport const SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32,\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    tDepth: { value: null },\n    tNoise: { value: null },\n    kernel: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n    resolution: { value: new Vector2() },\n    cameraProjectionMatrix: { value: new Matrix4() },\n    cameraInverseProjectionMatrix: { value: new Matrix4() },\n    kernelRadius: { value: 8 },\n    minDistance: { value: 0.005 },\n    maxDistance: { value: 0.05 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform sampler2D tNormal;',\n    'uniform sampler2D tDepth;',\n    'uniform sampler2D tNoise;',\n\n    'uniform vec3 kernel[ KERNEL_SIZE ];',\n\n    'uniform vec2 resolution;',\n\n    'uniform float cameraNear;',\n    'uniform float cameraFar;',\n    'uniform mat4 cameraProjectionMatrix;',\n    'uniform mat4 cameraInverseProjectionMatrix;',\n\n    'uniform float kernelRadius;',\n    'uniform float minDistance;', // avoid artifacts caused by neighbour fragments with minimal depth difference\n    'uniform float maxDistance;', // avoid the influence of fragments which are too far away\n\n    'varying vec2 vUv;',\n\n    '#include <packing>',\n\n    'float getDepth( const in vec2 screenPosition ) {',\n\n    '\treturn texture2D( tDepth, screenPosition ).x;',\n\n    '}',\n\n    'float getLinearDepth( const in vec2 screenPosition ) {',\n\n    '\t#if PERSPECTIVE_CAMERA == 1',\n\n    '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;',\n    '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );',\n    '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );',\n\n    '\t#else',\n\n    '\t\treturn texture2D( tDepth, screenPosition ).x;',\n\n    '\t#endif',\n\n    '}',\n\n    'float getViewZ( const in float depth ) {',\n\n    '\t#if PERSPECTIVE_CAMERA == 1',\n\n    '\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\n\n    '\t#else',\n\n    '\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\n\n    '\t#endif',\n\n    '}',\n\n    'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {',\n\n    '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];',\n\n    '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );',\n\n    '\tclipPosition *= clipW; // unprojection.',\n\n    '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;',\n\n    '}',\n\n    'vec3 getViewNormal( const in vec2 screenPosition ) {',\n\n    '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );',\n\n    '}',\n\n    'void main() {',\n\n    '\tfloat depth = getDepth( vUv );',\n    '\tfloat viewZ = getViewZ( depth );',\n\n    '\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );',\n    '\tvec3 viewNormal = getViewNormal( vUv );',\n\n    ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );',\n    '\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;',\n\n    // compute matrix used to reorient a kernel vector\n\n    '\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );',\n    '\tvec3 bitangent = cross( viewNormal, tangent );',\n    '\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );',\n\n    ' float occlusion = 0.0;',\n\n    ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {',\n\n    '\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];', // reorient sample vector in view space\n    '\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );', // calculate sample point\n\n    '\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );', // project point and calculate NDC\n    '\t\tsamplePointNDC /= samplePointNDC.w;',\n\n    '\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;', // compute uv coordinates\n\n    '\t\tfloat realDepth = getLinearDepth( samplePointUv );', // get linear depth from depth texture\n    '\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );', // compute linear depth of the sample view Z value\n    '\t\tfloat delta = sampleDepth - realDepth;',\n\n    '\t\tif ( delta > minDistance && delta < maxDistance ) {', // if fragment is before sample point, increase occlusion\n\n    '\t\t\tocclusion += 1.0;',\n\n    '\t\t}',\n\n    '\t}',\n\n    '\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );',\n\n    '\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );',\n\n    '}',\n  ].join('\\n'),\n}\n\nexport const SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n  },\n\n  uniforms: {\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDepth;',\n\n    'uniform float cameraNear;',\n    'uniform float cameraFar;',\n\n    'varying vec2 vUv;',\n\n    '#include <packing>',\n\n    'float getLinearDepth( const in vec2 screenPosition ) {',\n\n    '\t#if PERSPECTIVE_CAMERA == 1',\n\n    '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;',\n    '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );',\n    '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );',\n\n    '\t#else',\n\n    '\t\treturn texture2D( tDepth, screenPosition ).x;',\n\n    '\t#endif',\n\n    '}',\n\n    'void main() {',\n\n    '\tfloat depth = getLinearDepth( vUv );',\n    '\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );',\n\n    '}',\n  ].join('\\n'),\n}\n\nexport const SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: new Vector2() },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n\n    'uniform vec2 resolution;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec2 texelSize = ( 1.0 / resolution );',\n    '\tfloat result = 0.0;',\n\n    '\tfor ( int i = - 2; i <= 2; i ++ ) {',\n\n    '\t\tfor ( int j = - 2; j <= 2; j ++ ) {',\n\n    '\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;',\n    '\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;',\n\n    '\t\t}',\n\n    '\t}',\n\n    '\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );',\n\n    '}',\n  ].join('\\n'),\n}\n"],"mappings":";AASO,MAAMA,UAAA,GAAa;EACxBC,OAAA,EAAS;IACPC,kBAAA,EAAoB;IACpBC,WAAA,EAAa;EACf;EAEAC,QAAA,EAAU;IACRC,QAAA,EAAU;MAAEC,KAAA,EAAO;IAAK;IACxBC,OAAA,EAAS;MAAED,KAAA,EAAO;IAAK;IACvBE,MAAA,EAAQ;MAAEF,KAAA,EAAO;IAAK;IACtBG,MAAA,EAAQ;MAAEH,KAAA,EAAO;IAAK;IACtBI,MAAA,EAAQ;MAAEJ,KAAA,EAAO;IAAK;IACtBK,UAAA,EAAY;MAAEL,KAAA,EAAO;IAAK;IAC1BM,SAAA,EAAW;MAAEN,KAAA,EAAO;IAAK;IACzBO,UAAA,EAAY;MAAEP,KAAA,EAAO,IAAIQ,OAAA;IAAU;IACnCC,sBAAA,EAAwB;MAAET,KAAA,EAAO,IAAIU,OAAA;IAAU;IAC/CC,6BAAA,EAA+B;MAAEX,KAAA,EAAO,IAAIU,OAAA;IAAU;IACtDE,YAAA,EAAc;MAAEZ,KAAA,EAAO;IAAE;IACzBa,WAAA,EAAa;MAAEb,KAAA,EAAO;IAAM;IAC5Bc,WAAA,EAAa;MAAEd,KAAA,EAAO;IAAK;EAC7B;EAEAe,YAAA,EAAc,CACZ,qBAEA,iBAEA,cAEA,8EAEA,KACAC,IAAA,CAAK,IAAI;EAEXC,cAAA,EAAgB,CACd,+BACA,8BACA,6BACA,6BAEA,uCAEA,4BAEA,6BACA,4BACA,wCACA,+CAEA,+BACA;EAAA;EACA;EAAA;EAEA,qBAEA,sBAEA,oDAEA,kDAEA,KAEA,0DAEA,gCAEA,+DACA,iFACA,sEAEA,UAEA,mDAEA,WAEA,KAEA,4CAEA,gCAEA,qEAEA,UAEA,sEAEA,WAEA,KAEA,sGAEA,uFAEA,oFAEA,4CAEA,iEAEA,KAEA,wDAEA,0EAEA,KAEA,iBAEA,mCACA,qCAEA,8DACA,4CAEA,sEACA;EAAA;EAIA,iFACA,mDACA,gEAEA,2BAEA,+CAEA;EAAA;EACA;EAAA;EAEA;EAAA;EACA,yCAEA;EAAA;EAEA;EAAA;EACA;EAAA;EACA,4CAEA;EAAA;EAEA,wBAEA,OAEA,MAEA,qEAEA,yDAEA,KACAD,IAAA,CAAK,IAAI;AACb;AAEO,MAAME,eAAA,GAAkB;EAC7BvB,OAAA,EAAS;IACPC,kBAAA,EAAoB;EACtB;EAEAE,QAAA,EAAU;IACRI,MAAA,EAAQ;MAAEF,KAAA,EAAO;IAAK;IACtBK,UAAA,EAAY;MAAEL,KAAA,EAAO;IAAK;IAC1BM,SAAA,EAAW;MAAEN,KAAA,EAAO;IAAK;EAC3B;EAEAe,YAAA,EAAc,CACZ,qBAEA,iBAEA,cACA,8EAEA,KACAC,IAAA,CAAK,IAAI;EAEXC,cAAA,EAAgB,CACd,6BAEA,6BACA,4BAEA,qBAEA,sBAEA,0DAEA,gCAEA,+DACA,iFACA,sEAEA,UAEA,mDAEA,WAEA,KAEA,iBAEA,yCACA,qDAEA,KACAD,IAAA,CAAK,IAAI;AACb;AAEO,MAAMG,cAAA,GAAiB;EAC5BrB,QAAA,EAAU;IACRC,QAAA,EAAU;MAAEC,KAAA,EAAO;IAAK;IACxBO,UAAA,EAAY;MAAEP,KAAA,EAAO,IAAIQ,OAAA;IAAU;EACrC;EAEAO,YAAA,EAAc,CACZ,qBAEA,iBAEA,cACA,8EAEA,KACAC,IAAA,CAAK,IAAI;EAEXC,cAAA,EAAgB,CACd,+BAEA,4BAEA,qBAEA,iBAEA,2CACA,wBAEA,wCAEA,yCAEA,oEACA,uDAEA,OAEA,MAEA,gEAEA,KACAD,IAAA,CAAK,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}