{"ast":null,"code":"import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad) {\n  const v = useThree(state => state.viewport);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (textureUrl || input) {\n      new Promise(resolve => {\n        textureLoader.load(textureUrl !== null && textureUrl !== void 0 ? textureUrl : input, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        const frameWidth = width / numberOfFrames;\n        const frameHeight = height;\n        totalFrames.current = numberOfFrames;\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (let i = 0; i < numberOfFrames; i++) {\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    // @ts-ignore\n    if ('encoding' in _spriteTexture) _spriteTexture.encoding = 3001; // sRGBEncoding\n    // @ts-ignore\n    else _spriteTexture.colorSpace = 'srgb';\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters && Array.isArray(data['frames'])) {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const value of data['frames']) {\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else if (delimiters && typeof data['frames'] === 'object') {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else {\n      // we need to convert it into an array\n      const spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      return spritesArr;\n    }\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\nexport { calculateAspectRatio, getFirstItem, useSpriteLoader };","map":{"version":3,"names":["THREE","TextureLoader","useThree","useLoader","React","useState","getFirstItem","param","Array","isArray","keys","Object","w","h","calculateAspectRatio","width","height","factor","v","adaptedHeight","aspect","adaptedWidth","scaleX","scaleY","currentMaxScale","finalMaxScaleW","Math","min","finalMaxScaleH","Vector3","useSpriteLoader","input","json","animationNames","numberOfFrames","onLoad","state","viewport","spriteDataRef","useRef","totalFrames","aspectFactor","spriteData","setSpriteData","spriteTexture","setSpriteTexture","Texture","textureLoader","spriteObj","setSpriteObj","useLayoutEffect","loadJsonAndTextureAndExecuteCallback","parseSpriteData","loadStandaloneSprite","clear","loadJsonAndTexture","textureUrl","jsonUrl","Promise","resolve","load","then","texture","callback","jsonPromise","fetch","response","texturePromise","all","_spriteTexture","image","frameWidth","frameHeight","current","frames","meta","version","size","scale","parseInt","toString","i","push","frame","x","y","rotated","trimmed","spriteSourceSize","sourceSize","parseFrames","length","encoding","colorSpace","sprites","data","delimiters","value","frameData","sourceWidth","sourceHeight","toLowerCase","indexOf","innerKey","spritesArr","key","preload","url"],"sources":["D:/valentines_website/node_modules/@react-three/drei/core/useSpriteLoader.js"],"sourcesContent":["import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad) {\n  const v = useThree(state => state.viewport);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (textureUrl || input) {\n      new Promise(resolve => {\n        textureLoader.load(textureUrl !== null && textureUrl !== void 0 ? textureUrl : input, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        const frameWidth = width / numberOfFrames;\n        const frameHeight = height;\n        totalFrames.current = numberOfFrames;\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (let i = 0; i < numberOfFrames; i++) {\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    // @ts-ignore\n    if ('encoding' in _spriteTexture) _spriteTexture.encoding = 3001; // sRGBEncoding\n    // @ts-ignore\n    else _spriteTexture.colorSpace = 'srgb';\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters && Array.isArray(data['frames'])) {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const value of data['frames']) {\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else if (delimiters && typeof data['frames'] === 'object') {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else {\n      // we need to convert it into an array\n      const spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      return spritesArr;\n    }\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\n\nexport { calculateAspectRatio, getFirstItem, useSpriteLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}