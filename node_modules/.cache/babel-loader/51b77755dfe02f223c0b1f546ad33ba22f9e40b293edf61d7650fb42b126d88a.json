{"ast":null,"code":"import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1e3\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: [\"#include <common>\", \"uniform vec2 size;\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"void main() {\", \"\tvUv = uv;\", \"\tvInvSize = 1.0 / size;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#include <common>\", \"#include <packing>\", \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform float depthCutoff;\", \"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\", \"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tif( depth >= ( 1.0 - EPSILON ) ) {\", \"\t\tdiscard;\", \"\t}\", \"\tfloat centerViewZ = -getViewZ( depth );\", \"\tbool rBreak = false, lBreak = false;\", \"\tfloat weightSum = sampleWeights[0];\", \"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\", \"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\", \"\t\tfloat sampleWeight = sampleWeights[i];\", \"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\", \"\t\tvec2 sampleUv = vUv + sampleUvOffset;\", \"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\", \"\t\tif( ! rBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t\tsampleUv = vUv - sampleUvOffset;\", \"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\", \"\t\tif( ! lBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = diffuseSum / weightSum;\", \"}\"].join(\"\\n\")\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };","map":{"version":3,"names":["DepthLimitedBlurShader","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","Vector2","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","join","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","gaussian","x","stdDev2","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","shader","needsUpdate"],"sources":["D:\\valentines_website\\node_modules\\src\\shaders\\DepthLimitedBlurShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type DepthLimitedBlurShaderDefines = {\n  DEPTH_PACKING: number\n  KERNEL_RADIUS: number\n  PERSPECTIVE_CAMERA: number\n}\n\nexport type DepthLimitedBlurShaderUniforms = {\n  cameraFar: IUniform<number>\n  cameraNear: IUniform<number>\n  depthCutoff: IUniform<number>\n  sampleUvOffsets: IUniform<Vector2[]>\n  sampleWeights: IUniform<number[]>\n  size: IUniform<Vector2>\n  tDepth: IUniform<Texture | null>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IDepthLimitedBlurShader\n  extends IShader<DepthLimitedBlurShaderUniforms, DepthLimitedBlurShaderDefines> {\n  defines: DepthLimitedBlurShaderDefines\n  needsUpdate?: boolean\n}\n\nexport const DepthLimitedBlurShader: IDepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1,\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    size: { value: new Vector2(512, 512) },\n    sampleUvOffsets: { value: [new Vector2(0, 0)] },\n    sampleWeights: { value: [1.0] },\n    tDepth: { value: null },\n    cameraNear: { value: 10 },\n    cameraFar: { value: 1000 },\n    depthCutoff: { value: 10 },\n  },\n  vertexShader: [\n    '#include <common>',\n\n    'uniform vec2 size;',\n\n    'varying vec2 vUv;',\n    'varying vec2 vInvSize;',\n\n    'void main() {',\n    '\tvUv = uv;',\n    '\tvInvSize = 1.0 / size;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n    '}',\n  ].join('\\n'),\n  fragmentShader: [\n    '#include <common>',\n    '#include <packing>',\n\n    'uniform sampler2D tDiffuse;',\n    'uniform sampler2D tDepth;',\n\n    'uniform float cameraNear;',\n    'uniform float cameraFar;',\n    'uniform float depthCutoff;',\n\n    'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];',\n    'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];',\n\n    'varying vec2 vUv;',\n    'varying vec2 vInvSize;',\n\n    'float getDepth( const in vec2 screenPosition ) {',\n    '\t#if DEPTH_PACKING == 1',\n    '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );',\n    '\t#else',\n    '\treturn texture2D( tDepth, screenPosition ).x;',\n    '\t#endif',\n    '}',\n\n    'float getViewZ( const in float depth ) {',\n    '\t#if PERSPECTIVE_CAMERA == 1',\n    '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\n    '\t#else',\n    '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\n    '\t#endif',\n    '}',\n\n    'void main() {',\n    '\tfloat depth = getDepth( vUv );',\n    '\tif( depth >= ( 1.0 - EPSILON ) ) {',\n    '\t\tdiscard;',\n    '\t}',\n\n    '\tfloat centerViewZ = -getViewZ( depth );',\n    '\tbool rBreak = false, lBreak = false;',\n\n    '\tfloat weightSum = sampleWeights[0];',\n    '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;',\n\n    '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {',\n\n    '\t\tfloat sampleWeight = sampleWeights[i];',\n    '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;',\n\n    '\t\tvec2 sampleUv = vUv + sampleUvOffset;',\n    '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );',\n\n    '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;',\n\n    '\t\tif( ! rBreak ) {',\n    '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\n    '\t\t\tweightSum += sampleWeight;',\n    '\t\t}',\n\n    '\t\tsampleUv = vUv - sampleUvOffset;',\n    '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );',\n\n    '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;',\n\n    '\t\tif( ! lBreak ) {',\n    '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\n    '\t\t\tweightSum += sampleWeight;',\n    '\t\t}',\n\n    '\t}',\n\n    '\tgl_FragColor = diffuseSum / weightSum;',\n    '}',\n  ].join('\\n'),\n}\n\nexport const BlurShaderUtils = {\n  createSampleWeights: (kernelRadius: number, stdDev: number): number[] => {\n    const gaussian = (x: number, stdDev: number): number => {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev)\n    }\n\n    const weights: number[] = []\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev))\n    }\n\n    return weights\n  },\n\n  createSampleOffsets: (kernelRadius: number, uvIncrement: Vector2): Vector2[] => {\n    const offsets: Vector2[] = []\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i))\n    }\n\n    return offsets\n  },\n\n  configure: (shader: IDepthLimitedBlurShader, kernelRadius: number, stdDev: number, uvIncrement: Vector2): void => {\n    shader.defines['KERNEL_RADIUS'] = kernelRadius\n    shader.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement)\n    shader.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev)\n    shader.needsUpdate = true\n  },\n}\n"],"mappings":";AA2BO,MAAMA,sBAAA,GAAkD;EAC7DC,OAAA,EAAS;IACPC,aAAA,EAAe;IACfC,aAAA,EAAe;IACfC,kBAAA,EAAoB;EACtB;EACAC,QAAA,EAAU;IACRC,QAAA,EAAU;MAAEC,KAAA,EAAO;IAAK;IACxBC,IAAA,EAAM;MAAED,KAAA,EAAO,IAAIE,OAAA,CAAQ,KAAK,GAAG;IAAE;IACrCC,eAAA,EAAiB;MAAEH,KAAA,EAAO,CAAC,IAAIE,OAAA,CAAQ,GAAG,CAAC,CAAC;IAAE;IAC9CE,aAAA,EAAe;MAAEJ,KAAA,EAAO,CAAC,CAAG;IAAE;IAC9BK,MAAA,EAAQ;MAAEL,KAAA,EAAO;IAAK;IACtBM,UAAA,EAAY;MAAEN,KAAA,EAAO;IAAG;IACxBO,SAAA,EAAW;MAAEP,KAAA,EAAO;IAAK;IACzBQ,WAAA,EAAa;MAAER,KAAA,EAAO;IAAG;EAC3B;EACAS,YAAA,EAAc,CACZ,qBAEA,sBAEA,qBACA,0BAEA,iBACA,cACA,2BAEA,8EACA,KACAC,IAAA,CAAK,IAAI;EACXC,cAAA,EAAgB,CACd,qBACA,sBAEA,+BACA,6BAEA,6BACA,4BACA,8BAEA,sDACA,qDAEA,qBACA,0BAEA,oDACA,2BACA,qEACA,UACA,kDACA,WACA,KAEA,4CACA,gCACA,oEACA,UACA,qEACA,WACA,KAEA,iBACA,mCACA,uCACA,cACA,MAEA,4CACA,yCAEA,wCACA,8DAEA,iDAEA,4CACA,0DAEA,2CACA,sDAEA,mEAEA,sBACA,oEACA,iCACA,OAEA,sCACA,gDAEA,mEAEA,sBACA,oEACA,iCACA,OAEA,MAEA,2CACA,KACAD,IAAA,CAAK,IAAI;AACb;AAEO,MAAME,eAAA,GAAkB;EAC7BC,mBAAA,EAAqBA,CAACC,YAAA,EAAsBC,MAAA,KAA6B;IACjE,MAAAC,QAAA,GAAWA,CAACC,CAAA,EAAWC,OAAA,KAA2B;MACtD,OAAOC,IAAA,CAAKC,GAAA,CAAI,EAAEH,CAAA,GAAIA,CAAA,KAAM,KAAOC,OAAA,GAASA,OAAA,EAAQ,KAAKC,IAAA,CAAKE,IAAA,CAAK,IAAMF,IAAA,CAAKG,EAAE,IAAIJ,OAAA;IAAA;IAGtF,MAAMK,OAAA,GAAoB;IAE1B,SAASC,CAAA,GAAI,GAAGA,CAAA,IAAKV,YAAA,EAAcU,CAAA,IAAK;MACtCD,OAAA,CAAQE,IAAA,CAAKT,QAAA,CAASQ,CAAA,EAAGT,MAAM,CAAC;IAClC;IAEO,OAAAQ,OAAA;EACT;EAEAG,mBAAA,EAAqBA,CAACZ,YAAA,EAAsBa,WAAA,KAAoC;IAC9E,MAAMC,OAAA,GAAqB;IAE3B,SAASJ,CAAA,GAAI,GAAGA,CAAA,IAAKV,YAAA,EAAcU,CAAA,IAAK;MACtCI,OAAA,CAAQH,IAAA,CAAKE,WAAA,CAAYE,KAAA,CAAQ,EAAAC,cAAA,CAAeN,CAAC,CAAC;IACpD;IAEO,OAAAI,OAAA;EACT;EAEAG,SAAA,EAAWA,CAACC,MAAA,EAAiClB,YAAA,EAAsBC,MAAA,EAAgBY,WAAA,KAA+B;IACzGK,MAAA,CAAAtC,OAAA,CAAQ,eAAe,IAAIoB,YAAA;IAClCkB,MAAA,CAAOlC,QAAA,CAAS,iBAAiB,EAAEE,KAAA,GAAQY,eAAA,CAAgBc,mBAAA,CAAoBZ,YAAA,EAAca,WAAW;IACxGK,MAAA,CAAOlC,QAAA,CAAS,eAAe,EAAEE,KAAA,GAAQY,eAAA,CAAgBC,mBAAA,CAAoBC,YAAA,EAAcC,MAAM;IACjGiB,MAAA,CAAOC,WAAA,GAAc;EACvB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}