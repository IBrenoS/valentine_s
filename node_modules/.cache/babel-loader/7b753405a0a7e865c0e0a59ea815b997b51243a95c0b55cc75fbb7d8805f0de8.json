{"ast":null,"code":"import { Vector3, Vector4, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from \"three\";\nimport { LineSegmentsGeometry } from \"./LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"./LineMaterial.js\";\nconst _start = new Vector3();\nconst _end = new Vector3();\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\nlet _ray, _instanceStart, _instanceEnd, _lineWidth;\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (let i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i);\n    _line.end.fromBufferAttribute(_instanceEnd, i);\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const near = -camera.near;\n  _ray.at(1, _ssOrigin);\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (let i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n      _end4.lerp(_start4, t);\n    }\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 16777215\n  })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = \"LineSegments2\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);\n    geometry.setAttribute(\"instanceDistanceStart\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n    geometry.setAttribute(\"instanceDistanceEnd\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    _instanceStart = geometry.attributes.instanceStart;\n    _instanceEnd = geometry.attributes.instanceEnd;\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    let sphereMargin;\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n    _sphere.radius += sphereMargin;\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    }\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    let boxMargin;\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n    _box.expandByScalar(boxMargin);\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n}\nexport { LineSegments2 };","map":{"version":3,"names":["_start","Vector3","_end","_start4","Vector4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_box","Box3","_sphere","Sphere","_clipToWorldVector","_ray","_instanceStart","_instanceEnd","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","raycastWorldUnits","lineSegments","intersects","i","l","count","start","fromBufferAttribute","end","pointOnLine","point","distanceSqToSegment","isInside","distanceTo","push","origin","object","face","faceIndex","uv","uv2","raycastScreenSpace","material","matrixWorld","geometry","instanceStart","attributes","instanceEnd","near","at","matrixWorldInverse","z","copy","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","MathUtils","isInClipSpace","LineSegments2","Mesh","constructor","LineSegmentsGeometry","LineMaterial","color","random","isLineSegments2","type","computeLineDistances","lineDistances","Float32Array","j","instanceDistanceBuffer","InstancedInterleavedBuffer","setAttribute","InterleavedBufferAttribute","raycast","raycaster","worldUnits","console","error","threshold","params","Line2","ray","linewidth","boundingSphere","computeBoundingSphere","sphereMargin","distanceToSphere","distanceToPoint","radius","intersectsSphere","boundingBox","computeBoundingBox","boxMargin","distanceToBox","expandByScalar","intersectsBox"],"sources":["D:\\valentines_website\\node_modules\\src\\lines\\LineSegments2.js"],"sourcesContent":["import {\n  Box3,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4,\n} from 'three'\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\n\nconst _start = new Vector3()\nconst _end = new Vector3()\n\nconst _start4 = new Vector4()\nconst _end4 = new Vector4()\n\nconst _ssOrigin = new Vector4()\nconst _ssOrigin3 = new Vector3()\nconst _mvMatrix = new Matrix4()\nconst _line = new Line3()\nconst _closestPoint = new Vector3()\n\nconst _box = new Box3()\nconst _sphere = new Sphere()\nconst _clipToWorldVector = new Vector4()\n\nlet _ray, _instanceStart, _instanceEnd, _lineWidth\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n  _clipToWorldVector.x = _lineWidth / resolution.width\n  _clipToWorldVector.y = _lineWidth / resolution.height\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (let i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i)\n    _line.end.fromBufferAttribute(_instanceEnd, i)\n\n    const pointOnLine = new Vector3()\n    const point = new Vector3()\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null,\n      })\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix\n  const material = lineSegments.material\n  const resolution = material.resolution\n  const matrixWorld = lineSegments.matrixWorld\n\n  const geometry = lineSegments.geometry\n  const instanceStart = geometry.attributes.instanceStart\n  const instanceEnd = geometry.attributes.instanceEnd\n\n  const near = -camera.near\n\n  //\n\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n  _ray.at(1, _ssOrigin)\n\n  // ndc space [ - 1.0, 1.0 ]\n  _ssOrigin.w = 1\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse)\n  _ssOrigin.applyMatrix4(projectionMatrix)\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w)\n\n  // screen space\n  _ssOrigin.x *= resolution.x / 2\n  _ssOrigin.y *= resolution.y / 2\n  _ssOrigin.z = 0\n\n  _ssOrigin3.copy(_ssOrigin)\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld)\n\n  for (let i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i)\n    _end4.fromBufferAttribute(instanceEnd, i)\n\n    _start4.w = 1\n    _end4.w = 1\n\n    // camera space\n    _start4.applyMatrix4(_mvMatrix)\n    _end4.applyMatrix4(_mvMatrix)\n\n    // skip the segment if it's entirely behind the camera\n    const isBehindCameraNear = _start4.z > near && _end4.z > near\n    if (isBehindCameraNear) {\n      continue\n    }\n\n    // trim the segment if it extends behind camera near\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z\n      const t = (_start4.z - near) / deltaDist\n      _start4.lerp(_end4, t)\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z\n      const t = (_end4.z - near) / deltaDist\n      _end4.lerp(_start4, t)\n    }\n\n    // clip space\n    _start4.applyMatrix4(projectionMatrix)\n    _end4.applyMatrix4(projectionMatrix)\n\n    // ndc space [ - 1.0, 1.0 ]\n    _start4.multiplyScalar(1 / _start4.w)\n    _end4.multiplyScalar(1 / _end4.w)\n\n    // screen space\n    _start4.x *= resolution.x / 2\n    _start4.y *= resolution.y / 2\n\n    _end4.x *= resolution.x / 2\n    _end4.y *= resolution.y / 2\n\n    // create 2d segment\n    _line.start.copy(_start4)\n    _line.start.z = 0\n\n    _line.end.copy(_end4)\n    _line.end.z = 0\n\n    // get closest point on ray to segment\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true)\n    _line.at(param, _closestPoint)\n\n    // check if the intersection point is within clip space\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param)\n    const isInClipSpace = zPos >= -1 && zPos <= 1\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i)\n      _line.end.fromBufferAttribute(instanceEnd, i)\n\n      _line.start.applyMatrix4(matrixWorld)\n      _line.end.applyMatrix4(matrixWorld)\n\n      const pointOnLine = new Vector3()\n      const point = new Vector3()\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null,\n      })\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLineSegments2 = true\n\n    this.type = 'LineSegments2'\n  }\n\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry\n\n    const instanceStart = geometry.attributes.instanceStart\n    const instanceEnd = geometry.attributes.instanceEnd\n    const lineDistances = new Float32Array(2 * instanceStart.count)\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i)\n      _end.fromBufferAttribute(instanceEnd, i)\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1]\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end)\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1) // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)) // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)) // d1\n\n    return this\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits\n    const camera = raycaster.camera\n\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.',\n      )\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0\n\n    _ray = raycaster.ray\n\n    const matrixWorld = this.matrixWorld\n    const geometry = this.geometry\n    const material = this.material\n\n    _lineWidth = material.linewidth + threshold\n\n    _instanceStart = geometry.attributes.instanceStart\n    _instanceEnd = geometry.attributes.instanceEnd\n\n    // check if we intersect the sphere bounds\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere()\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld)\n\n    // increase the sphere bounds by the worst case line screen space width\n    let sphereMargin\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin))\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution)\n    }\n\n    _sphere.radius += sphereMargin\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return\n    }\n\n    // check if we intersect the box bounds\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox()\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld)\n\n    // increase the box bounds by the worst case line width\n    let boxMargin\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin))\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution)\n    }\n\n    _box.expandByScalar(boxMargin)\n\n    if (_ray.intersectsBox(_box) === false) {\n      return\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects)\n    } else {\n      raycastScreenSpace(this, camera, intersects)\n    }\n  }\n}\n\nexport { LineSegments2 }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}