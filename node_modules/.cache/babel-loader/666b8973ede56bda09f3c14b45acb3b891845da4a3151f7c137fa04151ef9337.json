{"ast":null,"code":"/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {\n  let left = offset;\n  let right = offset + count - 1;\n  const pos = split.pos;\n  const axisOffset = split.axis * 2;\n\n  // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n  while (true) {\n    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {\n      left++;\n    }\n\n    // if a triangle center lies on the partition plane it is considered to be on the right side\n    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {\n      right--;\n    }\n    if (left < right) {\n      // we need to swap all of the information associated with the triangles at index\n      // left and right; that's the verts in the geometry index, the bounds,\n      // and perhaps the SAH planes\n      let t = indirectBuffer[left];\n      indirectBuffer[left] = indirectBuffer[right];\n      indirectBuffer[right] = t;\n\n      // swap bounds\n      for (let i = 0; i < 6; i++) {\n        let tb = triangleBounds[left * 6 + i];\n        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n        triangleBounds[right * 6 + i] = tb;\n      }\n      left++;\n      right--;\n    } else {\n      return left;\n    }\n  }\n}\nexport { partition_indirect };","map":{"version":3,"names":["partition_indirect","indirectBuffer","index","triangleBounds","offset","count","split","left","right","pos","axisOffset","axis","t","i","tb"],"sources":["D:/valentines_website/node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js"],"sourcesContent":["/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,kBAAkBA,CAAEC,cAAc,EAAEC,KAAK,EAAEC,cAAc,EAAEC,MAAM,EAAEC,KAAK,EAAEC,KAAK,EAAG;EAE1F,IAAIC,IAAI,GAAGH,MAAM;EACjB,IAAII,KAAK,GAAGJ,MAAM,GAAGC,KAAK,GAAG,CAAC;EAC9B,MAAMI,GAAG,GAAGH,KAAK,CAACG,GAAG;EACrB,MAAMC,UAAU,GAAGJ,KAAK,CAACK,IAAI,GAAG,CAAC;;EAEjC;EACA,OAAQ,IAAI,EAAG;IAEd,OAAQJ,IAAI,IAAIC,KAAK,IAAIL,cAAc,CAAEI,IAAI,GAAG,CAAC,GAAGG,UAAU,CAAE,GAAGD,GAAG,EAAG;MAExEF,IAAI,EAAG;IAER;;IAEA;IACA,OAAQA,IAAI,IAAIC,KAAK,IAAIL,cAAc,CAAEK,KAAK,GAAG,CAAC,GAAGE,UAAU,CAAE,IAAID,GAAG,EAAG;MAE1ED,KAAK,EAAG;IAET;IAEA,IAAKD,IAAI,GAAGC,KAAK,EAAG;MAEnB;MACA;MACA;MACA,IAAII,CAAC,GAAGX,cAAc,CAAEM,IAAI,CAAE;MAC9BN,cAAc,CAAEM,IAAI,CAAE,GAAGN,cAAc,CAAEO,KAAK,CAAE;MAChDP,cAAc,CAAEO,KAAK,CAAE,GAAGI,CAAC;;MAG3B;MACA,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;QAE9B,IAAIC,EAAE,GAAGX,cAAc,CAAEI,IAAI,GAAG,CAAC,GAAGM,CAAC,CAAE;QACvCV,cAAc,CAAEI,IAAI,GAAG,CAAC,GAAGM,CAAC,CAAE,GAAGV,cAAc,CAAEK,KAAK,GAAG,CAAC,GAAGK,CAAC,CAAE;QAChEV,cAAc,CAAEK,KAAK,GAAG,CAAC,GAAGK,CAAC,CAAE,GAAGC,EAAE;MAErC;MAEAP,IAAI,EAAG;MACPC,KAAK,EAAG;IAET,CAAC,MAAM;MAEN,OAAOD,IAAI;IAEZ;EAED;AAED;AAEA,SAASP,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}