{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Color, Vector2, BufferGeometry, Float32BufferAttribute } from \"three\";\nclass TessellateModifier {\n  constructor(maxEdgeLength = 0.1, maxIterations = 6) {\n    __publicField(this, \"maxEdgeLength\");\n    __publicField(this, \"maxIterations\");\n    __publicField(this, \"modify\", geometry => {\n      if (geometry.index !== null) {\n        geometry = geometry.toNonIndexed();\n      }\n      const maxIterations = this.maxIterations;\n      const maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength;\n      const va = new Vector3();\n      const vb = new Vector3();\n      const vc = new Vector3();\n      const vm = new Vector3();\n      const vs = [va, vb, vc, vm];\n      const na = new Vector3();\n      const nb = new Vector3();\n      const nc = new Vector3();\n      const nm = new Vector3();\n      const ns = [na, nb, nc, nm];\n      const ca = new Color();\n      const cb = new Color();\n      const cc = new Color();\n      const cm = new Color();\n      const cs = [ca, cb, cc, cm];\n      const ua = new Vector2();\n      const ub = new Vector2();\n      const uc = new Vector2();\n      const um = new Vector2();\n      const us = [ua, ub, uc, um];\n      const u2a = new Vector2();\n      const u2b = new Vector2();\n      const u2c = new Vector2();\n      const u2m = new Vector2();\n      const u2s = [u2a, u2b, u2c, u2m];\n      const attributes = geometry.attributes;\n      const hasNormals = attributes.normal !== void 0;\n      const hasColors = attributes.color !== void 0;\n      const hasUVs = attributes.uv !== void 0;\n      const hasUV2s = attributes.uv2 !== void 0;\n      let positions = attributes.position.array;\n      let normals = hasNormals ? attributes.normal.array : null;\n      let colors = hasColors ? attributes.color.array : null;\n      let uvs = hasUVs ? attributes.uv.array : null;\n      let uv2s = hasUV2s ? attributes.uv2.array : null;\n      let positions2 = positions;\n      let normals2 = normals;\n      let colors2 = colors;\n      let uvs2 = uvs;\n      let uv2s2 = uv2s;\n      let iteration = 0;\n      let tessellating = true;\n      function addTriangle(a, b, c) {\n        const v1 = vs[a];\n        const v2 = vs[b];\n        const v3 = vs[c];\n        positions2.push(v1.x, v1.y, v1.z);\n        positions2.push(v2.x, v2.y, v2.z);\n        positions2.push(v3.x, v3.y, v3.z);\n        if (hasNormals) {\n          const n1 = ns[a];\n          const n2 = ns[b];\n          const n3 = ns[c];\n          normals2.push(n1.x, n1.y, n1.z);\n          normals2.push(n2.x, n2.y, n2.z);\n          normals2.push(n3.x, n3.y, n3.z);\n        }\n        if (hasColors) {\n          const c1 = cs[a];\n          const c2 = cs[b];\n          const c3 = cs[c];\n          colors2.push(c1.r, c1.g, c1.b);\n          colors2.push(c2.r, c2.g, c2.b);\n          colors2.push(c3.r, c3.g, c3.b);\n        }\n        if (hasUVs) {\n          const u1 = us[a];\n          const u2 = us[b];\n          const u3 = us[c];\n          uvs2.push(u1.x, u1.y);\n          uvs2.push(u2.x, u2.y);\n          uvs2.push(u3.x, u3.y);\n        }\n        if (hasUV2s) {\n          const u21 = u2s[a];\n          const u22 = u2s[b];\n          const u23 = u2s[c];\n          uv2s2.push(u21.x, u21.y);\n          uv2s2.push(u22.x, u22.y);\n          uv2s2.push(u23.x, u23.y);\n        }\n      }\n      while (tessellating && iteration < maxIterations) {\n        iteration++;\n        tessellating = false;\n        positions = positions2;\n        positions2 = [];\n        if (hasNormals) {\n          normals = normals2;\n          normals2 = [];\n        }\n        if (hasColors) {\n          colors = colors2;\n          colors2 = [];\n        }\n        if (hasUVs) {\n          uvs = uvs2;\n          uvs2 = [];\n        }\n        if (hasUV2s) {\n          uv2s = uv2s2;\n          uv2s2 = [];\n        }\n        for (let i = 0, i2 = 0, il = positions.length; i < il; i += 9, i2 += 6) {\n          va.fromArray(positions, i + 0);\n          vb.fromArray(positions, i + 3);\n          vc.fromArray(positions, i + 6);\n          if (hasNormals && normals) {\n            na.fromArray(normals, i + 0);\n            nb.fromArray(normals, i + 3);\n            nc.fromArray(normals, i + 6);\n          }\n          if (hasColors && colors) {\n            ca.fromArray(colors, i + 0);\n            cb.fromArray(colors, i + 3);\n            cc.fromArray(colors, i + 6);\n          }\n          if (hasUVs && uvs) {\n            ua.fromArray(uvs, i2 + 0);\n            ub.fromArray(uvs, i2 + 2);\n            uc.fromArray(uvs, i2 + 4);\n          }\n          if (hasUV2s && uv2s) {\n            u2a.fromArray(uv2s, i2 + 0);\n            u2b.fromArray(uv2s, i2 + 2);\n            u2c.fromArray(uv2s, i2 + 4);\n          }\n          const dab = va.distanceToSquared(vb);\n          const dbc = vb.distanceToSquared(vc);\n          const dac = va.distanceToSquared(vc);\n          if (dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared) {\n            tessellating = true;\n            if (dab >= dbc && dab >= dac) {\n              vm.lerpVectors(va, vb, 0.5);\n              if (hasNormals) nm.lerpVectors(na, nb, 0.5);\n              if (hasColors) cm.lerpColors(ca, cb, 0.5);\n              if (hasUVs) um.lerpVectors(ua, ub, 0.5);\n              if (hasUV2s) u2m.lerpVectors(u2a, u2b, 0.5);\n              addTriangle(0, 3, 2);\n              addTriangle(3, 1, 2);\n            } else if (dbc >= dab && dbc >= dac) {\n              vm.lerpVectors(vb, vc, 0.5);\n              if (hasNormals) nm.lerpVectors(nb, nc, 0.5);\n              if (hasColors) cm.lerpColors(cb, cc, 0.5);\n              if (hasUVs) um.lerpVectors(ub, uc, 0.5);\n              if (hasUV2s) u2m.lerpVectors(u2b, u2c, 0.5);\n              addTriangle(0, 1, 3);\n              addTriangle(3, 2, 0);\n            } else {\n              vm.lerpVectors(va, vc, 0.5);\n              if (hasNormals) nm.lerpVectors(na, nc, 0.5);\n              if (hasColors) cm.lerpColors(ca, cc, 0.5);\n              if (hasUVs) um.lerpVectors(ua, uc, 0.5);\n              if (hasUV2s) u2m.lerpVectors(u2a, u2c, 0.5);\n              addTriangle(0, 1, 3);\n              addTriangle(3, 1, 2);\n            }\n          } else {\n            addTriangle(0, 1, 2);\n          }\n        }\n      }\n      const geometry2 = new BufferGeometry();\n      geometry2.setAttribute(\"position\", new Float32BufferAttribute(positions2, 3));\n      if (hasNormals) {\n        geometry2.setAttribute(\"normal\", new Float32BufferAttribute(normals2, 3));\n      }\n      if (hasColors) {\n        geometry2.setAttribute(\"color\", new Float32BufferAttribute(colors2, 3));\n      }\n      if (hasUVs) {\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(uvs2, 2));\n      }\n      if (hasUV2s) {\n        geometry2.setAttribute(\"uv2\", new Float32BufferAttribute(uv2s2, 2));\n      }\n      return geometry2;\n    });\n    this.maxEdgeLength = maxEdgeLength;\n    this.maxIterations = maxIterations;\n  }\n}\nexport { TessellateModifier };","map":{"version":3,"names":["TessellateModifier","constructor","maxEdgeLength","maxIterations","__publicField","geometry","index","toNonIndexed","maxEdgeLengthSquared","va","Vector3","vb","vc","vm","vs","na","nb","nc","nm","ns","ca","Color","cb","cc","cm","cs","ua","Vector2","ub","uc","um","us","u2a","u2b","u2c","u2m","u2s","attributes","hasNormals","normal","hasColors","color","hasUVs","uv","hasUV2s","uv2","positions","position","array","normals","colors","uvs","uv2s","positions2","normals2","colors2","uvs2","uv2s2","iteration","tessellating","addTriangle","a","b","c","v1","v2","v3","push","x","y","z","n1","n2","n3","c1","c2","c3","r","g","u1","u2","u3","u21","u22","u23","i","i2","il","length","fromArray","dab","distanceToSquared","dbc","dac","lerpVectors","lerpColors","geometry2","BufferGeometry","setAttribute","Float32BufferAttribute"],"sources":["D:\\valentines_website\\node_modules\\src\\modifiers\\TessellateModifier.ts"],"sourcesContent":["import { BufferGeometry, Color, Float32BufferAttribute, Vector2, Vector3 } from 'three'\n\n/**\n * Break faces with edges longer than maxEdgeLength\n */\n\nclass TessellateModifier {\n  public maxEdgeLength: number\n  public maxIterations: number\n\n  constructor(maxEdgeLength = 0.1, maxIterations = 6) {\n    this.maxEdgeLength = maxEdgeLength\n    this.maxIterations = maxIterations\n  }\n\n  public modify = (geometry: BufferGeometry): BufferGeometry => {\n    if (geometry.index !== null) {\n      geometry = geometry.toNonIndexed()\n    }\n\n    //\n\n    const maxIterations = this.maxIterations\n    const maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength\n\n    const va = new Vector3()\n    const vb = new Vector3()\n    const vc = new Vector3()\n    const vm = new Vector3()\n    const vs = [va, vb, vc, vm]\n\n    const na = new Vector3()\n    const nb = new Vector3()\n    const nc = new Vector3()\n    const nm = new Vector3()\n    const ns = [na, nb, nc, nm]\n\n    const ca = new Color()\n    const cb = new Color()\n    const cc = new Color()\n    const cm = new Color()\n    const cs = [ca, cb, cc, cm]\n\n    const ua = new Vector2()\n    const ub = new Vector2()\n    const uc = new Vector2()\n    const um = new Vector2()\n    const us = [ua, ub, uc, um]\n\n    const u2a = new Vector2()\n    const u2b = new Vector2()\n    const u2c = new Vector2()\n    const u2m = new Vector2()\n    const u2s = [u2a, u2b, u2c, u2m]\n\n    const attributes = geometry.attributes\n    const hasNormals = attributes.normal !== undefined\n    const hasColors = attributes.color !== undefined\n    const hasUVs = attributes.uv !== undefined\n    const hasUV2s = attributes.uv2 !== undefined\n\n    let positions = attributes.position.array\n    let normals = hasNormals ? attributes.normal.array : null\n    let colors = hasColors ? attributes.color.array : null\n    let uvs = hasUVs ? attributes.uv.array : null\n    let uv2s = hasUV2s ? attributes.uv2.array : null\n\n    let positions2 = (positions as unknown) as number[]\n    let normals2 = (normals as unknown) as number[]\n    let colors2 = (colors as unknown) as number[]\n    let uvs2 = (uvs as unknown) as number[]\n    let uv2s2 = (uv2s as unknown) as number[]\n\n    let iteration = 0\n    let tessellating = true\n\n    function addTriangle(a: number, b: number, c: number): void {\n      const v1 = vs[a]\n      const v2 = vs[b]\n      const v3 = vs[c]\n\n      positions2.push(v1.x, v1.y, v1.z)\n      positions2.push(v2.x, v2.y, v2.z)\n      positions2.push(v3.x, v3.y, v3.z)\n\n      if (hasNormals) {\n        const n1 = ns[a]\n        const n2 = ns[b]\n        const n3 = ns[c]\n\n        normals2.push(n1.x, n1.y, n1.z)\n        normals2.push(n2.x, n2.y, n2.z)\n        normals2.push(n3.x, n3.y, n3.z)\n      }\n\n      if (hasColors) {\n        const c1 = cs[a]\n        const c2 = cs[b]\n        const c3 = cs[c]\n\n        colors2.push(c1.r, c1.g, c1.b)\n        colors2.push(c2.r, c2.g, c2.b)\n        colors2.push(c3.r, c3.g, c3.b)\n      }\n\n      if (hasUVs) {\n        const u1 = us[a]\n        const u2 = us[b]\n        const u3 = us[c]\n\n        uvs2.push(u1.x, u1.y)\n        uvs2.push(u2.x, u2.y)\n        uvs2.push(u3.x, u3.y)\n      }\n\n      if (hasUV2s) {\n        const u21 = u2s[a]\n        const u22 = u2s[b]\n        const u23 = u2s[c]\n\n        uv2s2.push(u21.x, u21.y)\n        uv2s2.push(u22.x, u22.y)\n        uv2s2.push(u23.x, u23.y)\n      }\n    }\n\n    while (tessellating && iteration < maxIterations) {\n      iteration++\n      tessellating = false\n\n      positions = positions2 as any\n      positions2 = []\n\n      if (hasNormals) {\n        normals = normals2 as any\n        normals2 = []\n      }\n\n      if (hasColors) {\n        colors = colors2 as any\n        colors2 = []\n      }\n\n      if (hasUVs) {\n        uvs = uvs2 as any\n        uvs2 = []\n      }\n\n      if (hasUV2s) {\n        uv2s = uv2s2 as any\n        uv2s2 = []\n      }\n\n      for (let i = 0, i2 = 0, il = positions.length; i < il; i += 9, i2 += 6) {\n        va.fromArray(positions, i + 0)\n        vb.fromArray(positions, i + 3)\n        vc.fromArray(positions, i + 6)\n\n        if (hasNormals && normals) {\n          na.fromArray(normals, i + 0)\n          nb.fromArray(normals, i + 3)\n          nc.fromArray(normals, i + 6)\n        }\n\n        if (hasColors && colors) {\n          ca.fromArray(colors, i + 0)\n          cb.fromArray(colors, i + 3)\n          cc.fromArray(colors, i + 6)\n        }\n\n        if (hasUVs && uvs) {\n          ua.fromArray(uvs, i2 + 0)\n          ub.fromArray(uvs, i2 + 2)\n          uc.fromArray(uvs, i2 + 4)\n        }\n\n        if (hasUV2s && uv2s) {\n          u2a.fromArray(uv2s, i2 + 0)\n          u2b.fromArray(uv2s, i2 + 2)\n          u2c.fromArray(uv2s, i2 + 4)\n        }\n\n        const dab = va.distanceToSquared(vb)\n        const dbc = vb.distanceToSquared(vc)\n        const dac = va.distanceToSquared(vc)\n\n        if (dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared) {\n          tessellating = true\n\n          if (dab >= dbc && dab >= dac) {\n            vm.lerpVectors(va, vb, 0.5)\n            if (hasNormals) nm.lerpVectors(na, nb, 0.5)\n            if (hasColors) cm.lerpColors(ca, cb, 0.5)\n            if (hasUVs) um.lerpVectors(ua, ub, 0.5)\n            if (hasUV2s) u2m.lerpVectors(u2a, u2b, 0.5)\n\n            addTriangle(0, 3, 2)\n            addTriangle(3, 1, 2)\n          } else if (dbc >= dab && dbc >= dac) {\n            vm.lerpVectors(vb, vc, 0.5)\n            if (hasNormals) nm.lerpVectors(nb, nc, 0.5)\n            if (hasColors) cm.lerpColors(cb, cc, 0.5)\n            if (hasUVs) um.lerpVectors(ub, uc, 0.5)\n            if (hasUV2s) u2m.lerpVectors(u2b, u2c, 0.5)\n\n            addTriangle(0, 1, 3)\n            addTriangle(3, 2, 0)\n          } else {\n            vm.lerpVectors(va, vc, 0.5)\n            if (hasNormals) nm.lerpVectors(na, nc, 0.5)\n            if (hasColors) cm.lerpColors(ca, cc, 0.5)\n            if (hasUVs) um.lerpVectors(ua, uc, 0.5)\n            if (hasUV2s) u2m.lerpVectors(u2a, u2c, 0.5)\n\n            addTriangle(0, 1, 3)\n            addTriangle(3, 1, 2)\n          }\n        } else {\n          addTriangle(0, 1, 2)\n        }\n      }\n    }\n\n    const geometry2 = new BufferGeometry()\n\n    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3))\n\n    if (hasNormals) {\n      geometry2.setAttribute('normal', new Float32BufferAttribute(normals2 as any, 3))\n    }\n\n    if (hasColors) {\n      geometry2.setAttribute('color', new Float32BufferAttribute(colors2 as any, 3))\n    }\n\n    if (hasUVs) {\n      geometry2.setAttribute('uv', new Float32BufferAttribute(uvs2 as any, 2))\n    }\n\n    if (hasUV2s) {\n      geometry2.setAttribute('uv2', new Float32BufferAttribute(uv2s2 as any, 2))\n    }\n\n    return geometry2\n  }\n}\n\nexport { TessellateModifier }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}