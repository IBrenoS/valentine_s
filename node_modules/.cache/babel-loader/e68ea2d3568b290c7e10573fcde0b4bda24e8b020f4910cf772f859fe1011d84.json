{"ast":null,"code":"import { Matrix4, Object3D, Vector3, EventDispatcher, BufferGeometry, Float32BufferAttribute, MathUtils, Matrix3, Color, Box3, Sphere, BufferAttribute, Vector2 } from \"three\";\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry();\n    const geometry = object.geometry;\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n      buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n      }\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry();\n    }\n    return buffergeometry;\n  }\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = \"\";\n    this.type = \"Geometry\";\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n  rotateX(angle) {\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : void 0;\n    const attributes = geometry.attributes;\n    if (attributes.position === void 0) {\n      console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n      return this;\n    }\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== void 0) this.faceVertexUvs[1] = [];\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n      if (color !== void 0) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === void 0 ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === void 0 ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n      if (uv !== void 0) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n      if (uv2 !== void 0) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n    const groups = geometry.groups;\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== void 0) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== void 0) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n    this.computeFaceNormals();\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n  computeFaceNormals() {\n    const cb = new Vector3(),\n      ab = new Vector3();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n    if (areaWeighted) {\n      const cb = new Vector3(),\n        ab = new Vector3();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeMorphNormals() {\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    }\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n      const morphNormals = this.morphNormals[i];\n      tmpGeo.vertices = this.morphTargets[i].vertices;\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n      return;\n    }\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n      vertices1 = this.vertices,\n      vertices2 = geometry.vertices,\n      faces1 = this.faces,\n      faces2 = geometry.faces,\n      colors1 = this.colors,\n      colors2 = geometry.colors;\n    if (matrix !== void 0) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    }\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== void 0) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    }\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    }\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n        faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n      if (normalMatrix !== void 0) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n        if (normalMatrix !== void 0) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n        faceCopy.vertexNormals.push(normal);\n      }\n      faceCopy.color.copy(face.color);\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    }\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0) this.faceVertexUvs[i] = [];\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n          uvsCopy = [];\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n      return;\n    }\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {};\n    const unique = [],\n      changes = [];\n    const precision = Math.pow(10, precisionPoints);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n      if (verticesMap[key] === void 0) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        changes[i] = changes[verticesMap[key]];\n      }\n    }\n    const faceIndicesToRemove = [];\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c];\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    }\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n  setFromPoints(points) {\n    this.vertices = [];\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n    return this;\n  }\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length;\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    }\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n    faces.sort(materialIndexSort);\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"Geometry\",\n        generator: \"Geometry.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\") data.name = this.name;\n    if (this.parameters !== void 0) {\n      const parameters = this.parameters;\n      for (let key in parameters) {\n        if (parameters[key] !== void 0) data[key] = parameters[key];\n      }\n      return data;\n    }\n    const vertices = [];\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false;\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0);\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n      if (normalsHash[hash] !== void 0) {\n        return normalsHash[hash];\n      }\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n      if (colorsHash[hash] !== void 0) {\n        return colorsHash[hash];\n      }\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n      if (uvsHash[hash] !== void 0) {\n        return uvsHash[hash];\n      }\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs];\n    data.data.faces = faces;\n    return data;\n  }\n  clone() {\n    return new Geometry().copy(this);\n  }\n  copy(source) {\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.name = source.name;\n    const vertices = source.vertices;\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    }\n    const colors = source.colors;\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    }\n    const faces = source.faces;\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    }\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0) {\n        this.faceVertexUvs[i] = [];\n      }\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n          uvsCopy = [];\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n    const morphTargets = source.morphTargets;\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name;\n      if (morphTargets[i].vertices !== void 0) {\n        morphTarget.vertices = [];\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      }\n      if (morphTargets[i].normals !== void 0) {\n        morphTarget.normals = [];\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n      this.morphTargets.push(morphTarget);\n    }\n    const morphNormals = source.morphNormals;\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {};\n      if (morphNormals[i].vertexNormals !== void 0) {\n        morphNormal.vertexNormals = [];\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      }\n      if (morphNormals[i].faceNormals !== void 0) {\n        morphNormal.faceNormals = [];\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n      this.morphNormals.push(morphNormal);\n    }\n    const skinWeights = source.skinWeights;\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    }\n    const skinIndices = source.skinIndices;\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    }\n    const lineDistances = source.lineDistances;\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    }\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute(\"position\", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute(\"color\", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute(\"uv2\", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    }\n    buffergeometry.groups = geometry.groups;\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n      buffergeometry.morphAttributes[name] = array;\n    }\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n    }\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n    return buffergeometry;\n  }\n  computeTangents() {\n    console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n  }\n  computeLineDistances() {\n    console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\");\n  }\n  applyMatrix(matrix) {\n    console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: \"dispose\"\n    });\n  }\n}\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = void 0;\n    const faces = geometry.faces;\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n        if (group !== void 0) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n    if (group !== void 0) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n    this.groups = groups;\n  }\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.position = morphTargetsPosition;\n    }\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.normal = morphTargetsNormal;\n    }\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length;\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n    }\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n      const vertexColors = face.vertexColors;\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n        if (vertexUvs !== void 0) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n        if (vertexUvs !== void 0) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      }\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    return this;\n  }\n}\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n    return this;\n  }\n}\nexport { Face3, Geometry };","map":{"version":3,"names":["_m1","Matrix4","_obj","Object3D","_offset","Vector3","Geometry","EventDispatcher","createBufferGeometryFromObject","object","buffergeometry","BufferGeometry","geometry","isPoints","isLine","positions","Float32BufferAttribute","vertices","length","colors","setAttribute","copyVector3sArray","copyColorsArray","lineDistances","copyArray","boundingSphere","clone","boundingBox","isMesh","toBufferGeometry","constructor","isGeometry","uuid","MathUtils","generateUUID","name","type","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","applyMatrix4","matrix","normalMatrix","Matrix3","getNormalMatrix","i","il","vertex","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","scope","index","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","Color","addFace","a","b","c","materialIndex","vertexColors","Face3","Vector2","groups","group","start","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","Array","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","Box3","setFromPoints","Sphere","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mergeMesh","mesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","value","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","DirectGeometry","fromGeometry","Float32Array","BufferAttribute","copyVector2sArray","array","attribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","warn","dispose","dispatchEvent","computeGroups","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","isVector3","isArray","isColor"],"sources":["D:\\valentines_website\\node_modules\\src\\deprecated\\Geometry.js"],"sourcesContent":["import {\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  EventDispatcher,\n  Float32BufferAttribute,\n  Matrix3,\n  Matrix4,\n  MathUtils,\n  Object3D,\n  Sphere,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst _m1 = new Matrix4()\nconst _obj = new Object3D()\nconst _offset = new Vector3()\n\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry()\n\n    const geometry = object.geometry\n\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3)\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3)\n\n      buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices))\n      buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors))\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1)\n\n        buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances))\n      }\n\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone()\n      }\n\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone()\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry()\n    }\n\n    return buffergeometry\n  }\n\n  constructor() {\n    super()\n    this.isGeometry = true\n    this.uuid = MathUtils.generateUUID()\n\n    this.name = ''\n    this.type = 'Geometry'\n\n    this.vertices = []\n    this.colors = []\n    this.faces = []\n    this.faceVertexUvs = [[]]\n\n    this.morphTargets = []\n    this.morphNormals = []\n\n    this.skinWeights = []\n    this.skinIndices = []\n\n    this.lineDistances = []\n\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // update flags\n\n    this.elementsNeedUpdate = false\n    this.verticesNeedUpdate = false\n    this.uvsNeedUpdate = false\n    this.normalsNeedUpdate = false\n    this.colorsNeedUpdate = false\n    this.lineDistancesNeedUpdate = false\n    this.groupsNeedUpdate = false\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix)\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i]\n      vertex.applyMatrix4(matrix)\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i]\n      face.normal.applyMatrix3(normalMatrix).normalize()\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize()\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    this.verticesNeedUpdate = true\n    this.normalsNeedUpdate = true\n\n    return this\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n\n    _m1.makeRotationX(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n\n    _m1.makeRotationY(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n\n    _m1.makeRotationZ(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n\n    _m1.makeTranslation(x, y, z)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n\n    _m1.makeScale(x, y, z)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector)\n\n    _obj.updateMatrix()\n\n    this.applyMatrix4(_obj.matrix)\n\n    return this\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this\n\n    const index = geometry.index !== null ? geometry.index : undefined\n    const attributes = geometry.attributes\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.')\n      return this\n    }\n\n    const position = attributes.position\n    const normal = attributes.normal\n    const color = attributes.color\n    const uv = attributes.uv\n    const uv2 = attributes.uv2\n\n    if (uv2 !== undefined) this.faceVertexUvs[1] = []\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i))\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i))\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors =\n        color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()]\n\n      const vertexNormals =\n        normal === undefined\n          ? []\n          : [\n              new Vector3().fromBufferAttribute(normal, a),\n              new Vector3().fromBufferAttribute(normal, b),\n              new Vector3().fromBufferAttribute(normal, c),\n            ]\n\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex)\n\n      scope.faces.push(face)\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([\n          new Vector2().fromBufferAttribute(uv, a),\n          new Vector2().fromBufferAttribute(uv, b),\n          new Vector2().fromBufferAttribute(uv, c),\n        ])\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([\n          new Vector2().fromBufferAttribute(uv2, a),\n          new Vector2().fromBufferAttribute(uv2, b),\n          new Vector2().fromBufferAttribute(uv2, c),\n        ])\n      }\n    }\n\n    const groups = geometry.groups\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i]\n\n        const start = group.start\n        const count = group.count\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex)\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex)\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2))\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2)\n        }\n      }\n    }\n\n    this.computeFaceNormals()\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone()\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    return this\n  }\n\n  center() {\n    this.computeBoundingBox()\n\n    this.boundingBox.getCenter(_offset).negate()\n\n    this.translate(_offset.x, _offset.y, _offset.z)\n\n    return this\n  }\n\n  normalize() {\n    this.computeBoundingSphere()\n\n    const center = this.boundingSphere.center\n    const radius = this.boundingSphere.radius\n\n    const s = radius === 0 ? 1 : 1.0 / radius\n\n    const matrix = new Matrix4()\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1)\n\n    this.applyMatrix4(matrix)\n\n    return this\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n      ab = new Vector3()\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vA = this.vertices[face.a]\n      const vB = this.vertices[face.b]\n      const vC = this.vertices[face.c]\n\n      cb.subVectors(vC, vB)\n      ab.subVectors(vA, vB)\n      cb.cross(ab)\n\n      cb.normalize()\n\n      face.normal.copy(cb)\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length)\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3()\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n\n      const cb = new Vector3(),\n        ab = new Vector3()\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        const vA = this.vertices[face.a]\n        const vB = this.vertices[face.b]\n        const vC = this.vertices[face.c]\n\n        cb.subVectors(vC, vB)\n        ab.subVectors(vA, vB)\n        cb.cross(ab)\n\n        vertices[face.a].add(cb)\n        vertices[face.b].add(cb)\n        vertices[face.c].add(cb)\n      }\n    } else {\n      this.computeFaceNormals()\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        vertices[face.a].add(face.normal)\n        vertices[face.b].add(face.normal)\n        vertices[face.c].add(face.normal)\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize()\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a])\n        vertexNormals[1].copy(vertices[face.b])\n        vertexNormals[2].copy(vertices[face.c])\n      } else {\n        vertexNormals[0] = vertices[face.a].clone()\n        vertexNormals[1] = vertices[face.b].clone()\n        vertexNormals[2] = vertices[face.c].clone()\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals()\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal)\n        vertexNormals[1].copy(face.normal)\n        vertexNormals[2].copy(face.normal)\n      } else {\n        vertexNormals[0] = face.normal.clone()\n        vertexNormals[1] = face.normal.clone()\n        vertexNormals[2] = face.normal.clone()\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone()\n      } else {\n        face.__originalFaceNormal.copy(face.normal)\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = []\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone()\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i])\n        }\n      }\n    }\n\n    // use temp geometry to compute face and vertex normals for each morph\n\n    const tmpGeo = new Geometry()\n    tmpGeo.faces = this.faces\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {}\n        this.morphNormals[i].faceNormals = []\n        this.morphNormals[i].vertexNormals = []\n\n        const dstNormalsFace = this.morphNormals[i].faceNormals\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3()\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3(),\n          }\n\n          dstNormalsFace.push(faceNormal)\n          dstNormalsVertex.push(vertexNormals)\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]\n\n      // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices\n\n      // compute morph normals\n\n      tmpGeo.computeFaceNormals()\n      tmpGeo.computeVertexNormals()\n\n      // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        const faceNormal = morphNormals.faceNormals[f]\n        const vertexNormals = morphNormals.vertexNormals[f]\n\n        faceNormal.copy(face.normal)\n\n        vertexNormals.a.copy(face.vertexNormals[0])\n        vertexNormals.b.copy(face.vertexNormals[1])\n        vertexNormals.c.copy(face.vertexNormals[2])\n      }\n    }\n\n    // restore original normals\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      face.normal = face.__originalFaceNormal\n      face.vertexNormals = face.__originalVertexNormals\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    this.boundingBox.setFromPoints(this.vertices)\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices)\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry)\n      return\n    }\n\n    let normalMatrix\n    const vertexOffset = this.vertices.length,\n      vertices1 = this.vertices,\n      vertices2 = geometry.vertices,\n      faces1 = this.faces,\n      faces2 = geometry.faces,\n      colors1 = this.colors,\n      colors2 = geometry.colors\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix)\n    }\n\n    // vertices\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i]\n\n      const vertexCopy = vertex.clone()\n\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix)\n\n      vertices1.push(vertexCopy)\n    }\n\n    // colors\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone())\n    }\n\n    // faces\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i]\n      let normal, color\n      const faceVertexNormals = face.vertexNormals,\n        faceVertexColors = face.vertexColors\n\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset)\n      faceCopy.normal.copy(face.normal)\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize()\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone()\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize()\n        }\n\n        faceCopy.vertexNormals.push(normal)\n      }\n\n      faceCopy.color.copy(face.color)\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j]\n        faceCopy.vertexColors.push(color.clone())\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset\n\n      faces1.push(faceCopy)\n    }\n\n    // uvs\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i]\n\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = []\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n          uvsCopy = []\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone())\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy)\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh)\n      return\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix()\n\n    this.merge(mesh.geometry, mesh.matrix)\n  }\n\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {} // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n    const unique = [],\n      changes = []\n\n    const precision = Math.pow(10, precisionPoints)\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i]\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i\n        unique.push(this.vertices[i])\n        changes[i] = unique.length - 1\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]]\n      }\n    }\n\n    // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n    const faceIndicesToRemove = []\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i]\n\n      face.a = changes[face.a]\n      face.b = changes[face.b]\n      face.c = changes[face.c]\n\n      const indices = [face.a, face.b, face.c]\n\n      // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i)\n          break\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i]\n\n      this.faces.splice(idx, 1)\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1)\n      }\n    }\n\n    // Use unique set of vertices\n\n    const diff = this.vertices.length - unique.length\n    this.vertices = unique\n    return diff\n  }\n\n  setFromPoints(points) {\n    this.vertices = []\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i]\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0))\n    }\n\n    return this\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces\n    const length = faces.length\n\n    // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i\n    }\n\n    // sort faces\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex\n    }\n\n    faces.sort(materialIndexSort)\n\n    // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0]\n    const uvs2 = this.faceVertexUvs[1]\n\n    let newUvs1, newUvs2\n\n    if (uvs1 && uvs1.length === length) newUvs1 = []\n    if (uvs2 && uvs2.length === length) newUvs2 = []\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id\n\n      if (newUvs1) newUvs1.push(uvs1[id])\n      if (newUvs2) newUvs2.push(uvs2[id])\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON',\n      },\n    }\n\n    // standard Geometry serialization\n\n    data.uuid = this.uuid\n    data.type = this.type\n    if (this.name !== '') data.name = this.name\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key]\n      }\n\n      return data\n    }\n\n    const vertices = []\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i]\n      vertices.push(vertex.x, vertex.y, vertex.z)\n    }\n\n    const faces = []\n    const normals = []\n    const normalsHash = {}\n    const colors = []\n    const colorsHash = {}\n    const uvs = []\n    const uvsHash = {}\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i]\n\n      const hasMaterial = true\n      const hasFaceUv = false // deprecated\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined\n      const hasFaceNormal = face.normal.length() > 0\n      const hasFaceVertexNormal = face.vertexNormals.length > 0\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1\n      const hasFaceVertexColor = face.vertexColors.length > 0\n\n      let faceType = 0\n\n      faceType = setBit(faceType, 0, 0) // isQuad\n      faceType = setBit(faceType, 1, hasMaterial)\n      faceType = setBit(faceType, 2, hasFaceUv)\n      faceType = setBit(faceType, 3, hasFaceVertexUv)\n      faceType = setBit(faceType, 4, hasFaceNormal)\n      faceType = setBit(faceType, 5, hasFaceVertexNormal)\n      faceType = setBit(faceType, 6, hasFaceColor)\n      faceType = setBit(faceType, 7, hasFaceVertexColor)\n\n      faces.push(faceType)\n      faces.push(face.a, face.b, face.c)\n      faces.push(face.materialIndex)\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i]\n\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]))\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal))\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals\n\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]))\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color))\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors\n\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]))\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | (1 << position) : value & ~(1 << position)\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString()\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash]\n      }\n\n      normalsHash[hash] = normals.length / 3\n      normals.push(normal.x, normal.y, normal.z)\n\n      return normalsHash[hash]\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString()\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash]\n      }\n\n      colorsHash[hash] = colors.length\n      colors.push(color.getHex())\n\n      return colorsHash[hash]\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString()\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash]\n      }\n\n      uvsHash[hash] = uvs.length / 2\n      uvs.push(uv.x, uv.y)\n\n      return uvsHash[hash]\n    }\n\n    data.data = {}\n\n    data.data.vertices = vertices\n    data.data.normals = normals\n    if (colors.length > 0) data.data.colors = colors\n    if (uvs.length > 0) data.data.uvs = [uvs] // temporal backward compatibility\n    data.data.faces = faces\n\n    return data\n  }\n\n  clone() {\n    /*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n    return new Geometry().copy(this)\n  }\n\n  copy(source) {\n    // reset\n\n    this.vertices = []\n    this.colors = []\n    this.faces = []\n    this.faceVertexUvs = [[]]\n    this.morphTargets = []\n    this.morphNormals = []\n    this.skinWeights = []\n    this.skinIndices = []\n    this.lineDistances = []\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // name\n\n    this.name = source.name\n\n    // vertices\n\n    const vertices = source.vertices\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone())\n    }\n\n    // colors\n\n    const colors = source.colors\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone())\n    }\n\n    // faces\n\n    const faces = source.faces\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone())\n    }\n\n    // face vertex uvs\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i]\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = []\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n          uvsCopy = []\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k]\n\n          uvsCopy.push(uv.clone())\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy)\n      }\n    }\n\n    // morph targets\n\n    const morphTargets = source.morphTargets\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {}\n      morphTarget.name = morphTargets[i].name\n\n      // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = []\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone())\n        }\n      }\n\n      // normals\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = []\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone())\n        }\n      }\n\n      this.morphTargets.push(morphTarget)\n    }\n\n    // morph normals\n\n    const morphNormals = source.morphNormals\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}\n\n      // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = []\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j]\n          const destVertexNormal = {}\n\n          destVertexNormal.a = srcVertexNormal.a.clone()\n          destVertexNormal.b = srcVertexNormal.b.clone()\n          destVertexNormal.c = srcVertexNormal.c.clone()\n\n          morphNormal.vertexNormals.push(destVertexNormal)\n        }\n      }\n\n      // face normals\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = []\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone())\n        }\n      }\n\n      this.morphNormals.push(morphNormal)\n    }\n\n    // skin weights\n\n    const skinWeights = source.skinWeights\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone())\n    }\n\n    // skin indices\n\n    const skinIndices = source.skinIndices\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone())\n    }\n\n    // line distances\n\n    const lineDistances = source.lineDistances\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i])\n    }\n\n    // bounding box\n\n    const boundingBox = source.boundingBox\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone()\n    }\n\n    // bounding sphere\n\n    const boundingSphere = source.boundingSphere\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone()\n    }\n\n    // update flags\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate\n    this.verticesNeedUpdate = source.verticesNeedUpdate\n    this.uvsNeedUpdate = source.uvsNeedUpdate\n    this.normalsNeedUpdate = source.normalsNeedUpdate\n    this.colorsNeedUpdate = source.colorsNeedUpdate\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate\n    this.groupsNeedUpdate = source.groupsNeedUpdate\n\n    return this\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this)\n\n    const buffergeometry = new BufferGeometry()\n\n    const positions = new Float32Array(geometry.vertices.length * 3)\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices))\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3)\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals))\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3)\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors))\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2)\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs))\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2)\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2))\n    }\n\n    // groups\n\n    buffergeometry.groups = geometry.groups\n\n    // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = []\n      const morphTargets = geometry.morphTargets[name]\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i]\n\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3)\n        attribute.name = morphTarget.name\n\n        array.push(attribute.copyVector3sArray(morphTarget.data))\n      }\n\n      buffergeometry.morphAttributes[name] = array\n    }\n\n    // skinning\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4)\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices))\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4)\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights))\n    }\n\n    //\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone()\n    }\n\n    return buffergeometry\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.')\n  }\n\n  computeLineDistances() {\n    console.error(\n      'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.',\n    )\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().')\n    return this.applyMatrix4(matrix)\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: 'dispose' })\n  }\n}\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = []\n    this.normals = []\n    this.colors = []\n    this.uvs = []\n    this.uvs2 = []\n\n    this.groups = []\n\n    this.morphTargets = {}\n\n    this.skinWeights = []\n    this.skinIndices = []\n\n    // this.lineDistances = [];\n\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // update flags\n\n    this.verticesNeedUpdate = false\n    this.normalsNeedUpdate = false\n    this.colorsNeedUpdate = false\n    this.uvsNeedUpdate = false\n    this.groupsNeedUpdate = false\n  }\n\n  computeGroups(geometry) {\n    const groups = []\n\n    let group, i\n    let materialIndex = undefined\n\n    const faces = geometry.faces\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start\n          groups.push(group)\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex,\n        }\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start\n      groups.push(group)\n    }\n\n    this.groups = groups\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces\n    const vertices = geometry.vertices\n    const faceVertexUvs = geometry.faceVertexUvs\n\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0\n\n    // morphs\n\n    const morphTargets = geometry.morphTargets\n    const morphTargetsLength = morphTargets.length\n\n    let morphTargetsPosition\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = []\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: [],\n        }\n      }\n\n      this.morphTargets.position = morphTargetsPosition\n    }\n\n    const morphNormals = geometry.morphNormals\n    const morphNormalsLength = morphNormals.length\n\n    let morphTargetsNormal\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = []\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: [],\n        }\n      }\n\n      this.morphTargets.normal = morphTargetsNormal\n    }\n\n    // skins\n\n    const skinIndices = geometry.skinIndices\n    const skinWeights = geometry.skinWeights\n\n    const hasSkinIndices = skinIndices.length === vertices.length\n    const hasSkinWeights = skinWeights.length === vertices.length\n\n    //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.')\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c])\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2])\n      } else {\n        const normal = face.normal\n\n        this.normals.push(normal, normal, normal)\n      }\n\n      const vertexColors = face.vertexColors\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2])\n      } else {\n        const color = face.color\n\n        this.colors.push(color, color, color)\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i]\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i)\n\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2())\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i]\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i)\n\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2())\n        }\n      }\n\n      // morphs\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices\n\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c])\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i]\n\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c)\n      }\n\n      // skins\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c])\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c])\n      }\n    }\n\n    this.computeGroups(geometry)\n\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone()\n    }\n\n    return this\n  }\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a\n    this.b = b\n    this.c = c\n\n    this.normal = normal && normal.isVector3 ? normal : new Vector3()\n    this.vertexNormals = Array.isArray(normal) ? normal : []\n\n    this.color = color && color.isColor ? color : new Color()\n    this.vertexColors = Array.isArray(color) ? color : []\n\n    this.materialIndex = materialIndex\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n\n  copy(source) {\n    this.a = source.a\n    this.b = source.b\n    this.c = source.c\n\n    this.normal.copy(source.normal)\n    this.color.copy(source.color)\n\n    this.materialIndex = source.materialIndex\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone()\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone()\n    }\n\n    return this\n  }\n}\n\nexport { Face3, Geometry }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}