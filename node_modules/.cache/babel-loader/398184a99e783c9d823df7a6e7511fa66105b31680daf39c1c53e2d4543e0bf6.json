{"ast":null,"code":"import { Vector2 } from \"three\";\nconst ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: \"25.0\",\n    KERNEL_SIZE_INT: \"25\"\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: new Vector2(1953125e-9, 0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: [\"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform float cKernel[ KERNEL_SIZE_INT ];\", \"uniform sampler2D tDiffuse;\", \"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 imageCoord = vUv;\", \"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\", \"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\", \"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\", \"\t\timageCoord += uImageIncrement;\", \"\t}\", \"\tgl_FragColor = sum;\", \"}\"].join(\"\\n\"),\n  buildKernel: function (sigma) {\n    function gauss(x, sigma2) {\n      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));\n    }\n    const kMaxKernelSize = 25;\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);\n    const halfWidth = (kernelSize - 1) * 0.5;\n    const values = new Array(kernelSize);\n    let sum = 0;\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    }\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum;\n    return values;\n  }\n};\nexport { ConvolutionShader };","map":{"version":3,"names":["ConvolutionShader","defines","KERNEL_SIZE_FLOAT","KERNEL_SIZE_INT","uniforms","tDiffuse","value","uImageIncrement","Vector2","cKernel","vertexShader","join","fragmentShader","buildKernel","sigma","gauss","x","sigma2","Math","exp","kMaxKernelSize","kernelSize","min","ceil","halfWidth","values","Array","sum","i"],"sources":["D:\\valentines_website\\node_modules\\src\\shaders\\ConvolutionShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type ConvolutionShaderDefines = {\n  KERNEL_SIZE_FLOAT: string\n  KERNEL_SIZE_INT: string\n}\n\nexport type ConvolutionShaderUniforms = {\n  cKernel: IUniform<number[]>\n  tDiffuse: IUniform<Texture | null>\n  uImageIncrement: IUniform<Vector2>\n}\n\nexport interface IConvolutionShader extends IShader<ConvolutionShaderUniforms, ConvolutionShaderDefines> {\n  buildKernel: (sigma: number) => number[]\n}\n\nexport const ConvolutionShader: IConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25',\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    uImageIncrement: { value: new Vector2(0.001953125, 0.0) },\n    cKernel: { value: [] },\n  },\n\n  vertexShader: [\n    'uniform vec2 uImageIncrement;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float cKernel[ KERNEL_SIZE_INT ];',\n\n    'uniform sampler2D tDiffuse;',\n    'uniform vec2 uImageIncrement;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec2 imageCoord = vUv;',\n    '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );',\n\n    '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {',\n\n    '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];',\n    '\t\timageCoord += uImageIncrement;',\n\n    '\t}',\n\n    '\tgl_FragColor = sum;',\n\n    '}',\n  ].join('\\n'),\n\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n    function gauss(x: number, sigma: number): number {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma))\n    }\n\n    const kMaxKernelSize = 25\n\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3.0) + 1, kMaxKernelSize)\n\n    const halfWidth = (kernelSize - 1) * 0.5\n\n    const values: number[] = new Array(kernelSize)\n\n    let sum = 0.0\n\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma)\n      sum += values[i]\n    }\n\n    // normalize the kernel\n\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum\n\n    return values\n  },\n}\n"],"mappings":";AA0BO,MAAMA,iBAAA,GAAwC;EACnDC,OAAA,EAAS;IACPC,iBAAA,EAAmB;IACnBC,eAAA,EAAiB;EACnB;EAEAC,QAAA,EAAU;IACRC,QAAA,EAAU;MAAEC,KAAA,EAAO;IAAK;IACxBC,eAAA,EAAiB;MAAED,KAAA,EAAO,IAAIE,OAAA,CAAQ,YAAa,CAAG;IAAE;IACxDC,OAAA,EAAS;MAAEH,KAAA,EAAO;IAAG;EACvB;EAEAI,YAAA,EAAc,CACZ,iCAEA,qBAEA,iBAEA,wEACA,8EAEA,KACAC,IAAA,CAAK,IAAI;EAEXC,cAAA,EAAgB,CACd,6CAEA,+BACA,iCAEA,qBAEA,iBAEA,2BACA,2CAEA,kDAEA,8DACA,oCAEA,MAEA,wBAEA,KACAD,IAAA,CAAK,IAAI;EAEXE,WAAA,EAAa,SAAAA,CAAUC,KAAA,EAAO;IAGnB,SAAAC,MAAMC,CAAA,EAAWC,MAAA,EAAuB;MAC/C,OAAOC,IAAA,CAAKC,GAAA,CAAI,EAAEH,CAAA,GAAIA,CAAA,KAAM,IAAMC,MAAA,GAAQA,MAAA,CAAM;IAClD;IAEA,MAAMG,cAAA,GAAiB;IAEjB,MAAAC,UAAA,GAAaH,IAAA,CAAKI,GAAA,CAAI,IAAIJ,IAAA,CAAKK,IAAA,CAAKT,KAAA,GAAQ,CAAG,IAAI,GAAGM,cAAc;IAEpE,MAAAI,SAAA,IAAaH,UAAA,GAAa,KAAK;IAE/B,MAAAI,MAAA,GAAmB,IAAIC,KAAA,CAAML,UAAU;IAE7C,IAAIM,GAAA,GAAM;IAEV,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAIP,UAAA,EAAY,EAAEO,CAAA,EAAG;MACnCH,MAAA,CAAOG,CAAC,IAAIb,KAAA,CAAMa,CAAA,GAAIJ,SAAA,EAAWV,KAAK;MACtCa,GAAA,IAAOF,MAAA,CAAOG,CAAC;IACjB;IAIA,SAASA,CAAA,GAAI,GAAGA,CAAA,GAAIP,UAAA,EAAY,EAAEO,CAAA,EAAGH,MAAA,CAAOG,CAAC,KAAKD,GAAA;IAE3C,OAAAF,MAAA;EACT;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}